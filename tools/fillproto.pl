#!/usr/bin/perl
#
# Filter for building prototype info from C-files files
#
# $Id: fillproto.pl,v 1.10 2004/03/27 22:04:57 gray Exp $
#

use strict;
use IO::File;
use FileHandle;

my $no_proc_comments = "/*\n * no comments found for this procedure\n */\n";
my $no_var_comments = "/* no comments found for this variable */\n";

my $search_mark	= "\\/\\*<<<<<";
my $header = "/*<<<<<<<<<<  The below prototypes are auto-generated by " .
	"fillproto */";
my $trailer = "/*<<<<<<<<<<   This is end of the auto-generated output from " .
	"fillproto. */";

# program defines
my $cmp_prog = 'cmp';

#
# process the protoypes from $INPATH and print output to $OUTFILE
#
sub gen_protos {
	# read in the args to prototype
	my ($inpath, $outfile) = @_;

	my $comment = 0;
	my @thing_list = ();
	my @comm_list = ();
	my @ifdef_list = ();
	my @post_endif_list = ();
	my $ifdef_lvl_at_thing_start = 0;
	my $infile = new IO::File "< $inpath";

	my $line_c = 0;
	while ( <$infile> ) {
		$line_c++;

		# skip blank lines
		next if m,^\s*$,;

		# process an #if compiler directive
		if ( @thing_list == () && m,^\#\s*(if.*)\n, ) {
			$ifdef_lvl_at_thing_start++;
			push @ifdef_list, $1;
			next;
		}

		# process an #endif compiler directive
		if ( @thing_list == () && m,^\#\s*(endif.*)\n, ) {
			$ifdef_lvl_at_thing_start--;
			pop @ifdef_list;
			next;
		}

		# skip other preprocessor directives
		next if @thing_list == () && m,^\#,;

		# special handling of gnu-c attribute settings.
		if ( @thing_list
				&& m,^\s*/\*\s*(__attribute__.*\S)\s*\*/, ) {
			# append to the thing an ifdef of the attribute
			@thing_list = ( @thing_list , "#ifdef __GNUC__\n", "  $1\n",
				 "#endif\n" );
			next;
		}

		# are we starting a comment?
		if ( m,^\s*/\*, ) {
			if ( $comment == 1 ) {
				print "$inpath: Warning: nested comments near line $line_c.\n"
			}
			else {
				$comment = 1;
				@comm_list = ();
			}
			# line gets added below
		}

		# do we have a continuing comment?
		if ( $comment == 1 ) {
			@comm_list = ( @comm_list , $_ );
			$comment = 2 if m,.*\*/,;
			next;
		}

		# skip lines which are indented
		if ( @thing_list == () && m,^\s, ) {
			$comment = 0;
			@comm_list = ();
			next;
		}

		# skip open brace
		if ( @thing_list == () && ( m,^\{, || m,^\}, )) {
			$comment = 0;
			@comm_list = ();
			next;
		}

		# skip quote at start of line
		if ( @thing_list == () && m!^\"! ) {
			$comment = 0;
			@comm_list = ();
			next;
		}

		# skip C++/C99 comments
		if ( @thing_list == () && m,^//, ) {
			$comment = 0;
			@comm_list = ();
			next;
		}

		#
		# process a thing.  could be a prototype-able item or not
		#

		# append the current line to the thing
		push @thing_list, $_;

		my $thing = join ('', @thing_list);
		my $thing_copy = $thing;

		# strip off any comments so /* ; */ do not confuse us
		while ( $thing =~ s,/\*[^\000]*\*/,,g ) {
		}

		# do we not have an end of a it?
		next unless ( $thing =~ m,\{, || $thing =~ m,;\s*$, );

		# strip off any quotes so " ; " do not confuse us
		while ( $thing =~ s![\"][^\"]*[^\\][\"]!!g ) {
		}
		# strip off any single quotes so ' ; ' do not confuse us
		while ( $thing =~ s![\'][^\']*[^\\][\']!!g ) {
		}

		# do we have an end of the variable?
		next if ( $thing =~ m,=, && $thing !~ m,;, );

		# make sure we do not have a structure definition
		if ( ( $thing =~ m{^struct\s+\w+\s*\{?\s*$} )
		   || $thing =~ m,:, ) {
			# go down to the end of the loop
		}

		# skip things that we do not need to prototype
		elsif ( $thing =~ m,^\b(?:typedef|(?:__)?static|extern)\b, ) {
			# go down to the end of the loop
		}

		# is this a procedure/function?
		elsif ( $thing =~ m,^[^=]*\{,
			&& $thing_copy =~ m,^[^\s]*.*[\(].*[\)].*\{,s ) {

			# strip off end crap
			$thing_copy =~ s,\s*\n*\{.*,,;
			$thing_copy =~ s,\s*\n$,,;
			$thing_copy =~ s,\s*\n$,,;
			$thing_copy =~ s,\s*\n$,,;

			# do not add main() to the prototypes.
			next if $thing_copy =~ m,\smain\s*\(,;

			# print a spacer
			print $outfile "\n";

			# print out the ifdefs
			foreach my $ifdef ( @ifdef_list ) {
				print $outfile "#$ifdef\n";
			}

			# are their comments for the procedure?
			if ( $comment == 2 ) {
				print $outfile join ('', @comm_list);
			}
			else {
				print $outfile $no_proc_comments;
			}

			# print the decl
			print $outfile $thing_copy;
			if ($thing_copy =~ /;/) {
				print $outfile "\n";
			} else {
				print $outfile ";\n";
			}

			splice @ifdef_list, -@post_endif_list, @post_endif_list;
			@post_endif_list = ();

			# print out the associated endifs
			foreach my $ifdef ( reverse @ifdef_list ) {
				print $outfile "#endif /* $ifdef */\n";
			}
		}

		# it must be a variable if we are exporting it
		elsif ( $thing =~ m,^[^\{]*[=;], ) {

			# print a spacer
			print $outfile "\n";

			# print out the ifdefs
			foreach my $ifdef ( @ifdef_list ) {
				print $outfile "#$ifdef\n";
			}

			# handle the comments
			if ( $thing_copy !~ m,\*/\s*$, ) {
				if ( $comment == 2 ) {
					print $outfile join ('', @comm_list);
				}
				else {
					print $outfile $no_var_comments;
				}
			}

			# strip off any quotes so " ; " do not confuse us
			while ( $thing_copy =~ s![\'\"][^\000]*[^\\][\'\"]!!g ) {
			}
			# strip off any brackets [] = { } defs
			while ( $thing_copy =~ s,{[^{}]*},,g ) {
			}

			# remove everything past the = to the next ',' or ';'
			if ( $thing_copy =~ m,/\*, ) {
				$thing_copy =~ s|\s*=[^\000]*([,;])(.*/\*)|$1$2|;
			}
			else {
				$thing_copy =~ s|\s*=[^\000]*([,;])|$1|;
			}

			# take out array contents
			$thing_copy =~ s,\[(.*)\](\s*[=;]),\[/* $1 */\]$2,;
			$thing_copy =~ s,\s*\n$,,;
			$thing_copy =~ s,\s*\n$,,;
			$thing_copy =~ s,\s*\n$,,;

			print $outfile "extern\n";
			print $outfile "$thing_copy\n";

			# print out the associated endifs
			foreach my $ifdef ( reverse @ifdef_list ) {
				print $outfile "#endif /* $ifdef */\n";
			}
		}

		$comment = 0;
		@comm_list = ();
		@thing_list = ();
	} continue {
		# handle preprocessor conditionals inside a thing
		if (@ifdef_list && @thing_list) {
			if ( m,^\#\s*(if.*)\n, ) {
				push @ifdef_list, $1;
			} elsif ( m,^\#\s*(else.*)\n, ) {
				$thing_list[$#thing_list - 1] =~ s[\n$][;\n]
				    if grep { m~\)~ } @thing_list;
#				push @thing_list, $_ unless grep { /{/ } @thing_list;
			} elsif ( m,^\#\s*(endif.*)\n, ) {
				$thing_list[$#thing_list - 1] =~ s[\n$][;\n]
				    if grep { m~\)~ } @thing_list;
				# something weird happened;
				# an ifdef ended which started
				# outside the thing, so be wary
				# and copy verbatim the preprocs.

				push @post_endif_list, $1 if
				    @ifdef_list >= $ifdef_lvl_at_thing_start;
			}
		}
	}

	close ($infile);
}

###############################################################################
# main program
###############################################################################

#
# usage message
#
die "Usage:  $0 file1.c [file2.c ...]\n" if @ARGV == 0;

while ( my $cfile = shift ) {

	my $hfile = $cfile;
	$hfile =~ s/\.c/\.h/;
	my $tfile = $hfile . ".t";

	# does the $cfile exist?
	if (! -r $cfile ) {
		print STDERR "Cannot get prototype info from $cfile: $!\n";
		next;
	}
	# does the $hfile exist and is it writable
	next unless -r $hfile;

	# figure out module name
	my $module = $cfile;
	$module =~ s/\.c//;
	$module = "\U$module\E";

	# remove the tilda and temp files
	unlink ( $tfile );

	my $infile = new IO::File "< $hfile" || die "Can't open $hfile: $!\n";
	my $outfile = new IO::File "> $tfile" || die "Can't open $tfile: $!\n";

	my $found = 0;
	while ( <$infile> ) {
		if ( m/^$search_mark/ ) {

			# count ing search marks that we've found
			$found++;

			# if we are NOT working on the 1st found then continue;
			next unless $found == 1;

			# print the header
			print $outfile "$header\n";

			# get the prototypes from cfile
			gen_protos($cfile, $outfile);

			print $outfile "\n";

			# print the trailer
			print $outfile "$trailer\n";
			next;
		}

		# dump all lines unless we are after 1st mark and before 2nd
		print $outfile $_ unless $found == 1;
	}

	close ($infile);
	close ($outfile);

	# rearrange tilda and temp file file
	my $ret = system $cmp_prog, '-s', $tfile, $hfile
		|| die "Could not run cmp: $!\n";

	# were the files the same?
	if ( $ret / 256 == 0 ) {
		unlink ($tfile);
		next;
	}

	if ( ! -w $hfile ) {
		printf("Could not modify prototype for '%s', file write protected\n",
		    $hfile);
		unlink ($tfile);
	}
	else {
		printf("Added prototype for '%s' into '%s'\n", $cfile, $hfile);
		unlink ($hfile . "~");
		rename ($hfile, $hfile . "~");
		rename ($tfile, $hfile);
	}
}

exit (0);
