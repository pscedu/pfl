general reminders
- watch out for sizeof(type var[0])
- constify RPC replies in clients and requests in servers
- check all bulkserver()'s for free_desc()
- sweep tree for \b0[0-9] and fix bad permissions (711 -> 700 - slash?)
- ctlapi GETTREE?
- zap _P_U64, u64, u32, u16, u8
- investigate pthread_rwlocks for things like trees and large lists
- watch out for "a - b" in cmp functions overflowing
- investigate if our sched_yield() calls are correct
- watch out for lock reinitialization (i.e. LOCK_INIT twice)
- minimize ifdef's in pfl
- remove XXX comments
- keep "make build > /dev/null" clean
- check memset() for bad sizes sizeof(pg) vs. sizeof(*pg)
- watch for realloc(p, 0) returning NULL being okay

make
- rename ROOTDIR -> PROJ_BASE
- introduce APP_BASE

slash
- piggyback small readdirs directly into READDIR replies
- implement READDIRPLUS with basic stat(2) info for each dirent

pfl
- pfl: use "psc_" prefix and "_mt" (multithread-safe) postfix
- for psclog(), add extensibility mechanism for fmtstr,
  allowing app-specific callbacks (e.g. %r for zest clients)
- rename dynarray_hintlen -> dynarray_ensurelen
- create a generic refcnt manager for thread-safe activity
- consider adding a new keyword __local or something for thread-localized memory.
- add a pscthr_get() check in pscalloc and test
- psclog format specifier: timestamp difference
- investigate proper control socket permissions checks.  regular
  users should be able to read some stats but only root users
  should be able to issue exit commands, etc.  TCP sockets should
  inspect remote port to determine "authorization"
- add a check to ensure hash table size is not a direct power of two
- rename stree to vtree (variable number of children per branch)
- phase out hash1

zest
- test parity reconstruction service by rebuilding
  a block from each parity group
- investigate SIGPIPE mishandling in client zest library
  causing infinite loop
- investigate size of block addressing types causing
  unreasonable limits on maximum file system size, perhaps
  during file system creation time (hopefully only)
- research faster CRC operations
- make a proper solution when running out of parity groups
  when servicing clients.  possible solution:
    (o) block new file opens until parity groups from older
        descriptors are finished
- do not allow clients to sit on parity groups, need some
  kind of reap/reclamation mechanism
- move parity block into random positions in the raid scheme
  to avoid placing all parity data on the same disk.
  however skip these on disk fail rebuild

  note: have the fastest disks grab each successive block in a pg,
  deprecates need for zigs, or at least current complexity of zigs.
- pass sizeof(iovs) to client on CONNECT
- write back support on server
- add extattrs to zfs fuse
- get xattr working on fruits /bessemer
- the *at family of routines allow any fd, not just a dirfd.
  (1) fatalx where we cant use a non-dir fd
  (2) extended attribute use obviously cannot be implemented
  (3) try to support ../ paths that access other dirs/files
- zest user command to tag a file sync disregard
  rm(1) (link count reaches zero of file in fid namespace) won't do
  because there could still be open fd's to it, built into zsyncmgt
- new pull model for zest server to client:
  server RPCIO threads issue GETs to connected mount_zests
    (o) need some way to "multilock" on multiple requests sent
        to different clients
- when mount_zest is idle, have it merge dirty zcf zsb channels
- ensure libzestclient is not paritying over partial buffers
- investigate libgru for NUMA memory staging
- when ppm_total is set less than lc_size for !PPMF_AUTO, set
  ppm_max and check this value in other places to eventually
  decrease pool size
- move typedump to utils
- zestThread.h has no business being shared by all things in zestland
- have two iothrs access the same disk to shorten the time the disk
  is idle

development tool
- let wiki changes automatically email zest-devel@ like svn commits
