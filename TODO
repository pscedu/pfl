$Id$

general reminders
- watch out for sizeof(type var[0])
- constify RPC replies in clients and requests in servers
- check all bulkserver()'s for free_desc()
- sweep tree for \b0[0-9] and fix bad permissions (711 -> 700 - slash?)
- ctlapi GETTREE?
- investigate pthread_rwlocks for things like trees and large lists
- watch out for "a - b" in cmp functions overflowing, use CMP() instead
- investigate if our sched_yield() calls are correct
- watch out for lock reinitialization (i.e. LOCK_INIT twice)
- minimize ifdef's in pfl
- remove XXX comments
- keep "make build > /dev/null" clean
- check memset() for bad sizes sizeof(pg) vs. sizeof(*pg)
- watch for realloc(p, 0) returning NULL being okay
- deploy __thread in more places
- change inline to __inline
- void *pri data members can be removed on structures to save
  memory, as you can allocate >sizeof(struct) and point the
  private data pointer past

make
- rename ROOTDIR -> PROJ_BASE
- introduce APP_BASE

pfl
- pfl: use "psc_/pfl_" prefix and "_mt" (multithread-safe) postfix
- for psclog(), add extensibility mechanism for fmtstr,
  allowing app-specific callbacks (e.g. %r for zest clients)
- create a generic refcnt manager for thread-safe activity
- add a pscthr_get() check in pscalloc and test
- psclog format specifier: timestamp difference
- investigate proper control socket permissions checks.  regular
  users should be able to read some stats but only root users
  should be able to issue exit commands, etc.  TCP sockets should
  inspect remote port to determine "authorization"
- should hash tables be enforced by to n^^2-1 ??
- rename stree to vtree (variable number of children per branch)
- phase out hash1
- create vlocks: vector lock API when you need to lock multiple
  structures in a reqlock order fashion (hash tables and lists etc.)
- add custom sleep intervals for timerthr API
- fix endianess in RPCs
- add API for PSC mem failure, so we can plug into the memhandling
  paths when asprintf() fails instead of centralizing the logic over
  malloc().
- add struct members to hdrclean.pl
- have lc_getwait() do a sched_yield() after it grabs an item
- have psc_pool_return() NULL out the pointer arg released
- add a new lock API:
    (o) agnostic to underlying type (spin, etc.)
    (o) has a flag to mark for processing of critical
	section and wakeup when leaving section and wakes up
	others waiting
- in pscrpc_nbset_add(), try to push the RPC;
  if failure, do a reap(), and try once more
- change return codes in ctlapi to be two constants:

    PSC_CTLRET_OK - continue processing
    PSC_CTLRET_BAIL - drop the connection

  give them obscure values (42,43) and ensure they are returned
- ensure everything in pscrpc land is prefixed with 'pscrpc'
- RETURN() used in code is actually from libcfs.h
- rename bitflag.h -> bitstr.h
- let caller worry about memory for vbitmaps, don't return pointers
- bail if multiwait_addcond() fails
- psclist_add_sorted() - maintain a median element for faster sorting
- add a variable printbin()
- rename psc_bitstr_setchk -> psc_bitfield_setchk
- introduce refmgr
- ensure no mp RPC message bodies are used after a pscrpc_req_finished()
- add 'psc_' prefix to nbrequest API
- move pool to psc_util

zest
- research faster CRC operations
- do not allow clients to sit on parity groups, need some
  kind of reap/reclamation mechanism
- new RAID scheme: have the fastest disks grab each successive block
  in a pg, obviates need for zigs
- pass sizeof(iovs) to client on CONNECT
- add extattrs to zfs fuse
- get xattr working on fruits /bessemer
- the *at family of routines allow any fd, not just a dirfd.
  (1) fatalx where we cant use a non-dir fd
  (2) extended attribute use obviously cannot be implemented
  (3) try to support ../ paths that access other dirs/files
- zest user command to tag a file sync disregard
  rm(1) (link count reaches zero of file in fid namespace) won't do
  because there could still be open fd's to it, built into zsyncmgt
- new pull model for zest server to client:
  server RPCIO threads issue GETs to connected mount_zests
    (o) need some way to "multiwait" on multiple requests sent
	to different clients
- when mount_zest is idle, have it merge dirty zcf zsb channels
- ensure libzestclient is not paritying over partial buffers
- investigate libgru for NUMA memory staging
- when ppm_total is set less than lc_size for !PPMF_AUTO, set
  ppm_max and check this value in other places to eventually
  decrease pool size
- think about more ways to shorten disk idle time
- add auth checks into fdbuf from slash
- auto tune hash table sizes
- allow zctl to add disks/fix mode operation
- separate all ctlapi structures into substructures for easier copying vs.
  in-mem respresentations which need locks etc.

development tool
- let wiki changes automatically email zest/slash2-devel@ like svn commits
