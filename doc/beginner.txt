$Id$

Starting Guide for PFL, Zest, and SLASH

Terminology
===========

lnd - Lustre networking device.  LNDs are abstraction layers that let
	underlying protocols, such as TCP or Cray portals, handle lower-level
	communication details.

Control API Notes
=======================================

  Some global data structure instances get automatically registered for
  statistics exportation and manipulation through daemon control sockets.
  For example, the free read buffer list in zest is accessible like this:

    $ zctl -Lreadfree

  And the code just looks like this:

    #include "psc_ds/listcache.h"

    struct readbuf {
	...
	struct psclist_head rb_entry;
    };

    struct psc_listcache zReadBufferList;

    lc_reginit(&zreadBufferList, struct readbuf, rb_entry, "readfree");

Documentation
=============

  How to view manpages:

    $ nroff -mandoc foo.1

  and usually pipe it to a pager or somewhere.

Make Infrastructure
==================================

  To build most components, try "make build" first.  If make(1)
  complains that there is no "build" target, then try:

    $ make clean
    $ make depend
    $ make

 Maintaining File Dependencies
 -----------------------------

  You should re-run "make depend" any time any file changes/adds/removes
  a #include directive so file dependences are properly maintained.

 Other Make Targets
 ------------------

  To create a recursive code database for use with tagname lookups in
  vim (e.g. to go to functions/symbols by name), use the cscope target:

    $ make cs

  For emacs:

    $ make etags

  It is also advised to check code against lint(1) from time to time:

    $ make lint

  Most targets are recursive.  There are other targets in
  $PROJ_BASE/mk/main.mk.

Local Files
===========

  Program deployments will necessarily require some changes to
  configuration and/or other local repository files.  Please avoid
  committing to example configuration files or files called "local*"
  unless you know what you're doing, otherwise it may cause SVN merge
  conflicts on everyone's checkouts (including any other checkouts you
  may have).

Project Hierarchy
=================

lnet-lite - lower level networking library, used by pscrpc.
	If you require network communication abilities, see the pscrpc
	APIs instead.

mk - global make(1)/build infrastructure
	Note: individual projects may contain additional build rules and
	settings (such as include file directories pertinent to its
	various sources) in its $APP_ROOT/mk directory.

psc_fsutil_libs (PFL) - utility library defining common data structures
 |	and routines shared by zest & slash.
 |
 +- include - header files
     |
     +-	psc_types.h - primitive data types
     +-	psc_ds - code implementing various data structures
     |
     |		dynarray - dynamically resizable arrays using realloc()
     |		hash2 - hash table API
     |			(o) automatically registered for export/control
     |		list - linux/list.h rewrite, lightweight linked list implementation,
     |			NOT thread-safe (these routines must be invoked mutually
     |			exclusive sections of code e.g. protected by spinlocks)
     |		listcache - heavier duty linked list, thread-safe
     |			(o) automatically registered for export/control
     |		lockedlist - lightweight thread-safe linked list API
     |		pool - object memory management
     |			(o) automatically registered for export/control
     |		queue - BSD sys/queue.h, additional list/queue structures
     |			such as singly linked lists
     |		stree - simple tree where each node may have a variable
     |			number of branches/children
     |		tree - BSD sys/tree.h, contains two types of trees:
     |			(o) splay - auto-rebalancing two-child-node tree
     |			(o) red-black - glorified binary search tree
     |			documentation for this file is available here:
     |			http://www.openbsd.org/cgi-bin/man.cgi?query=tree
     |		vbitmap - arbitrarily-sized bitmaps (byte strings)
     |
     +-	psc_rpc - remote procedure call (RPC) library which leverages
     |	    the LNET networking library
     |		rsx - interface for simple RPC message communication
     |		the other files are split/shared between client/server activity
     |
     |		the zest client has an asynchronous I/O example
     |
     +-	psc_util - miscellaneous utility routines
     |
     |		acsvc - file system access control mechanism, for performing
     |			file system operations with other user privileges.
     |		alloc - validity-checked allocation routines supporting
     |			page-alignment and mlock(2)
     |		assert - assertions tied to logging system
     |		atomic - a data type which provies a variety of mathematical operations
     |			which by nature of atomic i.e mutually exclusive, ideal e.g. for
     |			thread-shared data structures containing members which need
     |			to be updated but shouldn't require the overhead of locking the
     |			structure
     |		cdefs - miscellaneous C definitions
     |		crc - cyclic redundancy checks for attempting to verify data integrity
     |		ctlcli - client interface for daemon control
     |		ctlsvr - server guts for daemon control
     |		fmt - string formatting APIs, such as human-readable sizes (2.5M)
     |		fmtstr - custom format strings, e.g. %M for minutes, %H for hours, etc.
     |		init - PFL initialization, key data structures and threads, etc.
     |		iostats - routines for gathering statistics about any form of I/O
     |			(o) automatically registered for export/control
     |		journal - journaling routines
     |		lock - simple spinlock implementation for mutually exclusive code sections
     |			spinlock() - necessarily acquire a spinlock,
     |				blocking until release if already held by another thread
     |			freelock() - release a held spinlock
     |			trylock() - attempt to grab a spinlock, returning false if another
     |				thread already holds it
     |
     |			reqlock() - require a spinlock for a section,
     |				ideal for recursive or highly nested program structure
     |			tryreqlock() - attempt to require a spinlock
     |			ureqlock() - (possibly) release a required lock,
     |				if not already held before corresponding reqlock()
     |		log - fine-grained logging API
     |			in PFL programs, there are a number of subsystems a program
     |			may register, e.g. in zest there is an inode subsystem which
     |			tracks open/active files, syncer subsystem in charge of moving
     |			data chunks to third-party file systems, parity rebuild subsystem
     |			in charge of reconstructing lost blocks, etc.
     |
     |			each subsystem has a loglevel associated with it which describes
     |			which kinds of messages (by severity) may be reported, and each
     |			thread has its own set of values for these.  these levels are
     |			all controllable via the control interface.
     |
     |			  psc_trace()	flow report
     |			  psc_info()	informational/diagnostic message
     |			  psc_dbg()	debugging messages
     |			  psc_notice()	condition alert
     |			  psc_warn()	non-critical error, append errno
     |			  psc_warnx()	non-critical error, not system-related
     |			  psc_error()	serious error, append errno to message
     |			  psc_errorx()	serious error, not system-related
     |			  psc_fatal()	fatal error, end program execution, with errno
     |			  psc_fatalx()	fatal error, end program execution, not sys-related
     |
     |		meter - API for progress meters
     |		mkdirs - "mkdir -p" in a function
     |		multiwait - pthread_cond/psc_waitq-like API for waiting of any of
     |			number of conditions to occur
     |		printhex - simple data printer in hexadecimal for debugging
     |		prsig - signal(2) behavior dumper
     |		pthread_barrier - thread barriers, for sync'ing everyone up before
     |			proceeding to further workloads.
     |		random - pseudo-random number generator based on /dev/urandom
     |		rlimit - resource limit (getrlimit(2)) API
     |		setprocesstitle - API for setting the ps(1) process name string
     |		strlcat - OpenBSD's NUL-guaranteed truncation-detecting strncat
     |		strlcpy - OpenBSD's NUL-guaranteed truncation-detecting strncpy
     |		subsys - routines relating to the "subsystem" facility which may be used
     |			to logically divide large program structure into modules
     |		thread - layer above pthread which gives you many things (basically,
     |			all thread-safe code in PFL deals with pscthreads and not
     |			pthreads directly)
     |		timerthr - API for dedicating threads to perform events periodically
     |		usklndthr - LNET userland socket LND module thread spawner
     |		waitq - wait on an event, from the context of a thread

slash_nara - root of slash-specific code
 +- include - shared include files
 |
 |	buffer - slab buffers for memory-resident file portions
 |	fid - global file ID definitions
 |	fidcache - managing a collection of in-core files
 |	inode - one in-core file
 |	offtree - "offset tree" for connecting file-logical positions
 |		to slab buffers efficiently
 |	slashrpc - slash RPC definitions
 |	slconfig - lex-based configuration parser definitions
 |
 +- mk - slash-specific build rules/definitions/customizations/etc.
 +- mount_slash - fuse mounter for slash, connects to slashd and sliod
 |
 |	control - control interface definitions
 |	mount_slash.c - core program definitions
 |	rpc - RPC routines specific to mount_slash
 |
 +- msctl - command-line mount_slash controller
 +- share - code amongst several slash-related programs
 +- slashd - MDS server
 |
 |	backend - inter- MDS and I/O daemon communication
 |	cfd - "client file descriptor" routines, which tracks client-scoped
 |		identifiers with active files
 |	control - control interface definitions
 |	dircache - cache for open(2) directory handles for efficiency
 |	fidcache - active file collection
 |	journal - slash-specific journalling routines
 |	lconf - lex definitions for slash.conf configuration parser
 |	mds - RPC messages for metadata exchange
 |	sb - slash file system superblock routines
 |	timer - timer subsystem routines, for periodic maintenance
 |	yconf - yacc rules/codes for slash.conf configuration parser
 |
 +- slctl - command-line slashd controller
 |
 +- sliod - I/O server
 |
 |	control - control interface definitions
 |	rpc - RPC routines specific to sliod
 |	timer - timer subsystem routines, for periodic maintenance
 |
 +- slioctl - command-line sliod controller

tools - miscellaneous development tools
 |
 +- Id.sh - a tool for fixing $Id$ tags in files
 +- libdep.pl - invoked by "make depend" for tracking libfoo.a and
 |		-lfoo on executables
 +- mkdep - a portable file dependency generator used by "make depend"
 +- notempty - simple utility for a workaround in the make
 |		infrastructure
 +- unwrapcc - a tool for finding the actual intended final $CC target
		when deep cc(1) wrappers are in use

Writing Makefiles
=================

  This section explains how to leverage the make infrastructure for
  building your programs.

  The structure of our make system is a bit weird but is so to allow
  programs/sources/paths to move around without requiring many pathname
  references to be updated.  This is what all the Makefile.path files
  are for.

  Now for writing your own.  First, list all source files your program
  consists of in SRCS:

	PROG=		foo
	SRCS+=		foo.c
	SRCS+=		bar.c

  Libraries (libmylib.a) are frowned upon for a number of reasons.
  Instead, add library files to your program SRCS variable:

	SRCS+=		${PFL_BASE}/psc_util/crc.c

  There are a number of convenience variables for large libraries:

	SRCS+=		${LNET_SOCKLND_SRCS}	# socket networking device
	SRCS+=		${LNET_CFS_SRCS}	# miscellaneous routines
	SRCS+=		${LNET_LIB_SRCS}	# message/mem routines
	SRCS+=		${LNET_PTLLND_SRCS}	# portals networking device
	SRCS+=		${PSCRPC_SRCS}		# pscrpc library

  Next, specify additional optional environmental factors:

	INCLUDES - a list of -I<path> passed to gcc and a few other places
	DEFINES - a list of -D<name>[=<value>] directives
	LDFLAGS - linker flags such as -lfoo or -L<path>

  Notes:
	- don't use CFLAGS directly unless you only want to pass a flag to gcc.
	  e.g. if you add CFLAGS+=-DFOO, then this define won't propagated to
	  other targets, such as "make define" or "make lint"
	- avoid hardcoding paths as much as possible, e.g.

		$ INCLUDES+=	-I${ZEST_BASE}/zestrpc

	  instead of

		$ INCLUDES+=	-I../../../zestrpc

	  or

		$ INCLUDES+=	-I${KERNEL_BASE}/include

	  instead of

		$ INCLUDES+=	-I/usr/src/kernels/2.6.9/include/stuff

  Finally, include rules for the project the program is a part of:

	include ${SLASHMK}
	include ${PLFMK}

Writing a PFL Program
=====================

 PFL initialization
  Every PFL application must invoke pfl_init() before it can access most
  PFL APIs.  This routine:
    (o) creates the subsystem facility to allow fine-grained logging
	capabilities
    (o) initializes the thread subsystem
    (o) initializes the NUMA local memory access subsystem
    (o) parses the environment as described in pflenv(7)

 psc_thread registration
  Every thread in a PFL application which invokes PFL APIs should invoke
  pscthr_init() to initialize some metathread structures.  This
  information can be access later with pscthr_get(), including thread-local
  storage via the pscthr_private field.

 LNET initialization
  Our modified LNET stack requests to the application to spawn a thread.
  PFL provides an implementation of these routines but requires that your
  application provides two routines to aid it in spawning:

    psc_usklndthr_getname()
    psc_usklndthr_gettype()

  See example implementations of these in zestiond.

 PSCRPC Layer: Storing per-connection data
  PSCRPC maintains a structure psc_export associated with each request
  which contains the peer information and contains a member:

    void *rq->rq_export->exp_privdata

  This can be used to store an application-specific (or task-specific)
  structure to associate data with the peer.
