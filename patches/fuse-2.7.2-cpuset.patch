diff -rup /usr/src/packages/SOURCES/fuse-2.7.2/fuse.pc fuse-2.7.2/fuse.pc
--- /usr/src/packages/SOURCES/fuse-2.7.2/fuse.pc	2008-10-24 16:22:11.109837477 -0400
+++ fuse-2.7.2/fuse.pc	2008-10-29 17:36:26.627264573 -0400
@@ -6,5 +6,5 @@ includedir=${prefix}/include
 Name: fuse
 Description: Filesystem in Userspace
 Version: 2.7.2
-Libs: -L${libdir} -lfuse -pthread -lrt -ldl  
+Libs: -L${libdir} -lfuse -pthread -lrt -ldl -lcpuset -lbitmask
 Cflags: -I${includedir}/fuse -D_FILE_OFFSET_BITS=64
diff -rup /usr/src/packages/SOURCES/fuse-2.7.2/kernel/dev.c fuse-2.7.2/kernel/dev.c
--- /usr/src/packages/SOURCES/fuse-2.7.2/kernel/dev.c	2007-10-16 12:35:22.000000000 -0400
+++ fuse-2.7.2/kernel/dev.c	2008-11-13 16:24:33.014288648 -0500
@@ -16,6 +16,7 @@
 #include <linux/pagemap.h>
 #include <linux/file.h>
 #include <linux/slab.h>
+#include <linux/cpuset.h>
 
 #ifdef MODULE_ALIAS_MISCDEV
 MODULE_ALIAS_MISCDEV(FUSE_MINOR);
@@ -250,10 +251,27 @@ static void wait_answer_interruptible(st
 	spin_lock(&fc->lock);
 }
 
+static int
+fcs_getcur(void)
+{
+	int nq, cpu;
+
+	cpu = task_cpu(current);
+	if (cpu < 0 || cpu >= NR_CPUS) {
+		printk("fuse error: task_cpu returned out of range cpu "
+		    "(%d), fabricating mem nid\n", cpu);
+		cpu = 0;
+	} 
+	nq = cpu_to_node(cpu);
+	if (nq >= MAX_NUMNODES || nq < 0)
+		nq = 0;
+	return (nq);
+} 
+
 static void queue_interrupt(struct fuse_conn *fc, struct fuse_req *req)
 {
 	list_add_tail(&req->intr_entry, &fc->interrupts);
-	wake_up(&fc->waitq);
+	wake_up(&fc->waitq[fcs_getcur()]);
 	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
 }
 
@@ -339,16 +357,19 @@ static u64 fuse_get_unique(struct fuse_c
 
 static void queue_request(struct fuse_conn *fc, struct fuse_req *req)
 {
+	int nq;
+
+	nq = fcs_getcur();
 	req->in.h.unique = fuse_get_unique(fc);
 	req->in.h.len = sizeof(struct fuse_in_header) +
 		len_args(req->in.numargs, (struct fuse_arg *) req->in.args);
-	list_add_tail(&req->list, &fc->pending);
+	list_add_tail(&req->list, &fc->pending[nq]);
 	req->state = FUSE_REQ_PENDING;
 	if (!req->waiting) {
 		req->waiting = 1;
 		atomic_inc(&fc->num_waiting);
 	}
-	wake_up(&fc->waitq);
+	wake_up(&fc->waitq[nq]);
 	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
 }
 
@@ -619,18 +640,18 @@ static int fuse_copy_args(struct fuse_co
 	return err;
 }
 
-static int request_pending(struct fuse_conn *fc)
+static int request_pending(struct fuse_conn *fc, int nq)
 {
-	return !list_empty(&fc->pending) || !list_empty(&fc->interrupts);
+	return !list_empty(&fc->pending[nq]) || !list_empty(&fc->interrupts);
 }
 
 /* Wait until a request is available on the pending list */
-static void request_wait(struct fuse_conn *fc)
+static void request_wait(struct fuse_conn *fc, int nq)
 {
 	DECLARE_WAITQUEUE(wait, current);
 
-	add_wait_queue_exclusive(&fc->waitq, &wait);
-	while (fc->connected && !request_pending(fc)) {
+	add_wait_queue_exclusive(&fc->waitq[nq], &wait);
+	while (fc->connected && !request_pending(fc, nq)) {
 		set_current_state(TASK_INTERRUPTIBLE);
 		if (signal_pending(current))
 			break;
@@ -640,7 +661,7 @@ static void request_wait(struct fuse_con
 		spin_lock(&fc->lock);
 	}
 	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&fc->waitq, &wait);
+	remove_wait_queue(&fc->waitq[nq], &wait);
 }
 
 /*
@@ -700,22 +721,25 @@ static ssize_t fuse_dev_readv(struct fil
 	struct fuse_copy_state cs;
 	unsigned reqsize;
 	struct fuse_conn *fc = fuse_get_conn(file);
+	int nq;
+
 	if (!fc)
 		return -EPERM;
 
+	nq = fcs_getcur();
  restart:
 	spin_lock(&fc->lock);
 	err = -EAGAIN;
 	if ((file->f_flags & O_NONBLOCK) && fc->connected &&
-	    !request_pending(fc))
+	    !request_pending(fc, nq))
 		goto err_unlock;
 
-	request_wait(fc);
+	request_wait(fc, nq);
 	err = -ENODEV;
 	if (!fc->connected)
 		goto err_unlock;
 	err = -ERESTARTSYS;
-	if (!request_pending(fc))
+	if (!request_pending(fc, nq))
 		goto err_unlock;
 
 	if (!list_empty(&fc->interrupts)) {
@@ -724,7 +748,7 @@ static ssize_t fuse_dev_readv(struct fil
 		return fuse_read_interrupt(fc, req, iov, nr_segs);
 	}
 
-	req = list_entry(fc->pending.next, struct fuse_req, list);
+	req = list_entry(fc->pending[nq].next, struct fuse_req, list);
 	req->state = FUSE_REQ_READING;
 	list_move(&req->list, &fc->io);
 
@@ -938,15 +962,18 @@ static unsigned fuse_dev_poll(struct fil
 {
 	unsigned mask = POLLOUT | POLLWRNORM;
 	struct fuse_conn *fc = fuse_get_conn(file);
+	int nq;
+
 	if (!fc)
 		return POLLERR;
 
-	poll_wait(file, &fc->waitq, wait);
+	nq = fcs_getcur();
+	poll_wait(file, &fc->waitq[nq], wait);
 
 	spin_lock(&fc->lock);
 	if (!fc->connected)
 		mask = POLLERR;
-	else if (request_pending(fc))
+	else if (request_pending(fc, nq))
 		mask |= POLLIN | POLLRDNORM;
 	spin_unlock(&fc->lock);
 
@@ -1025,14 +1052,18 @@ static void end_io_requests(struct fuse_
  */
 void fuse_abort_conn(struct fuse_conn *fc)
 {
+	int i;
+
 	spin_lock(&fc->lock);
 	if (fc->connected) {
 		fc->connected = 0;
 		fc->blocked = 0;
 		end_io_requests(fc);
-		end_requests(fc, &fc->pending);
+		for (i = 0; i < MAX_NUMNODES; i++)
+			end_requests(fc, &fc->pending[i]);
 		end_requests(fc, &fc->processing);
-		wake_up_all(&fc->waitq);
+		for (i = 0; i < MAX_NUMNODES; i++)
+			wake_up_all(&fc->waitq[i]);
 		wake_up_all(&fc->blocked_waitq);
 		kill_fasync(&fc->fasync, SIGIO, POLL_IN);
 	}
@@ -1042,10 +1073,13 @@ void fuse_abort_conn(struct fuse_conn *f
 static int fuse_dev_release(struct inode *inode, struct file *file)
 {
 	struct fuse_conn *fc = fuse_get_conn(file);
+	int i;
+
 	if (fc) {
 		spin_lock(&fc->lock);
 		fc->connected = 0;
-		end_requests(fc, &fc->pending);
+		for (i = 0; i < MAX_NUMNODES; i++)
+			end_requests(fc, &fc->pending[i]);
 		end_requests(fc, &fc->processing);
 		spin_unlock(&fc->lock);
 		fasync_helper(-1, file, 0, &fc->fasync);
diff -rup /usr/src/packages/SOURCES/fuse-2.7.2/kernel/file.c fuse-2.7.2/kernel/file.c
--- /usr/src/packages/SOURCES/fuse-2.7.2/kernel/file.c	2007-10-16 12:35:22.000000000 -0400
+++ fuse-2.7.2/kernel/file.c	2008-10-24 17:00:28.557034873 -0400
@@ -196,7 +196,7 @@ static u64 fuse_lock_owner_id(struct fus
 #ifdef KERNEL_2_6_18_PLUS
 static int fuse_flush(struct file *file, fl_owner_t id)
 #else
-static int fuse_flush(struct file *file)
+static int fuse_flush(struct file *file, fl_owner_t id)
 #endif
 {
 	struct inode *inode = file->f_dentry->d_inode;
@@ -794,11 +794,7 @@ static int fuse_file_lock(struct file *f
 			if (!posix_test_lock(file, fl, fl))
 				fl->fl_type = F_UNLCK;
 #else
-			struct file_lock *cfl = posix_test_lock(file, fl);
-			if (!cfl)
-				fl->fl_type = F_UNLCK;
-			else
-				*fl = *cfl;
+			posix_test_lock(file, fl);
 #endif
 			err = 0;
 		} else
diff -rup /usr/src/packages/SOURCES/fuse-2.7.2/kernel/fuse_i.h fuse-2.7.2/kernel/fuse_i.h
--- /usr/src/packages/SOURCES/fuse-2.7.2/kernel/fuse_i.h	2007-12-12 14:00:11.000000000 -0500
+++ fuse-2.7.2/kernel/fuse_i.h	2008-10-24 16:50:21.909050007 -0400
@@ -346,10 +346,10 @@ struct fuse_conn {
 	unsigned max_write;
 
 	/** Readers of the connection are waiting on this */
-	wait_queue_head_t waitq;
+	wait_queue_head_t waitq[MAX_NUMNODES];
 
 	/** The list of pending requests */
-	struct list_head pending;
+	struct list_head pending[MAX_NUMNODES];
 
 	/** The list of requests being processed */
 	struct list_head processing;
diff -rup /usr/src/packages/SOURCES/fuse-2.7.2/kernel/inode.c fuse-2.7.2/kernel/inode.c
--- /usr/src/packages/SOURCES/fuse-2.7.2/kernel/inode.c	2007-12-12 14:01:04.000000000 -0500
+++ fuse-2.7.2/kernel/inode.c	2008-10-24 17:02:50.518772247 -0400
@@ -248,6 +248,7 @@ static void fuse_send_destroy(struct fus
 static void fuse_put_super(struct super_block *sb)
 {
 	struct fuse_conn *fc = get_fuse_conn_super(sb);
+	int i;
 
 	fuse_send_destroy(fc);
 	spin_lock(&fc->lock);
@@ -256,7 +257,8 @@ static void fuse_put_super(struct super_
 	spin_unlock(&fc->lock);
 	/* Flush all readers on this fs */
 	kill_fasync(&fc->fasync, SIGIO, POLL_IN);
-	wake_up_all(&fc->waitq);
+	for (i = 0; i < MAX_NUMNODES; i++)
+		wake_up_all(&fc->waitq[i]);
 	wake_up_all(&fc->blocked_waitq);
 	wake_up_all(&fc->reserved_req_waitq);
 	mutex_lock(&fuse_mutex);
@@ -283,12 +285,10 @@ static void convert_fuse_statfs(struct k
 #ifdef KERNEL_2_6_18_PLUS
 static int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)
 #else
-static int fuse_statfs(struct super_block *sb, struct kstatfs *buf)
+static int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)
 #endif
 {
-#ifdef KERNEL_2_6_18_PLUS
 	struct super_block *sb = dentry->d_sb;
-#endif
 	struct fuse_conn *fc = get_fuse_conn_super(sb);
 	struct fuse_req *req;
 	struct fuse_statfs_out outarg;
@@ -467,16 +467,19 @@ static void *kzalloc(size_t size, int fl
 static struct fuse_conn *new_conn(void)
 {
 	struct fuse_conn *fc;
+	int i;
 
 	fc = kzalloc(sizeof(*fc), GFP_KERNEL);
 	if (fc) {
 		spin_lock_init(&fc->lock);
 		mutex_init(&fc->inst_mutex);
 		atomic_set(&fc->count, 1);
-		init_waitqueue_head(&fc->waitq);
+		for (i = 0; i < MAX_NUMNODES; i++)
+			init_waitqueue_head(&fc->waitq[i]);
 		init_waitqueue_head(&fc->blocked_waitq);
 		init_waitqueue_head(&fc->reserved_req_waitq);
-		INIT_LIST_HEAD(&fc->pending);
+		for (i = 0; i < MAX_NUMNODES; i++)
+			INIT_LIST_HEAD(&fc->pending[i]);
 		INIT_LIST_HEAD(&fc->processing);
 		INIT_LIST_HEAD(&fc->io);
 		INIT_LIST_HEAD(&fc->interrupts);
diff -rup /usr/src/packages/SOURCES/fuse-2.7.2/lib/fuse_loop_mt.c fuse-2.7.2/lib/fuse_loop_mt.c
--- /usr/src/packages/SOURCES/fuse-2.7.2/lib/fuse_loop_mt.c	2007-12-12 09:33:35.000000000 -0500
+++ fuse-2.7.2/lib/fuse_loop_mt.c	2008-11-13 14:01:26.510460993 -0500
@@ -6,6 +6,7 @@
   See the file COPYING.LIB.
 */
 
+#define _GNU_SOURCE
 #include "fuse_lowlevel.h"
 #include "fuse_misc.h"
 #include "fuse_kernel.h"
@@ -18,6 +19,12 @@
 #include <semaphore.h>
 #include <errno.h>
 #include <sys/time.h>
+#include <cpuset.h>
+#include <bitmask.h>
+#include <err.h>
+#include <sched.h>
+#include <sys/syscall.h>
+#include <numa.h>
 
 struct fuse_worker {
 	struct fuse_worker *prev;
@@ -30,8 +37,6 @@ struct fuse_worker {
 
 struct fuse_mt {
 	pthread_mutex_t lock;
-	int numworker;
-	int numavail;
 	struct fuse_session *se;
 	struct fuse_chan *prevch;
 	struct fuse_worker main;
@@ -57,12 +62,48 @@ static void list_del_worker(struct fuse_
 	next->prev = prev;
 }
 
-static int fuse_start_thread(struct fuse_mt *mt);
+struct thr_init {
+	int bindnode;
+	struct fuse_mt *mt;
+};
 
 static void *fuse_do_work(void *data)
 {
-	struct fuse_worker *w = (struct fuse_worker *) data;
-	struct fuse_mt *mt = w->mt;
+	struct thr_init *ti = data;
+	struct fuse_worker *w;
+	struct fuse_mt *mt = ti->mt;
+	nodemask_t nm;
+
+	nodemask_zero(&nm);
+	nodemask_set(&nm, ti->bindnode);
+	free(ti);
+	if (numa_run_on_node_mask(&nm) == -1) {
+		mt->error = -1;
+		return (NULL);
+	}
+	numa_set_membind(&nm);
+
+	w = malloc(sizeof(*w));
+	if (w == NULL) {
+		mt->error = -1;
+		return (NULL);
+	}
+
+	memset(w, 0, sizeof(*w));
+	w->mt = mt;
+	w->thread_id = pthread_self();
+	w->bufsize = fuse_chan_bufsize(mt->prevch);
+	w->buf = malloc(w->bufsize);
+	if (!w->buf) {
+		fprintf(stderr, "fuse: failed to allocate read buffer\n");
+		free(w);
+		mt->error = -1;
+		return (NULL);
+	}
+
+	pthread_mutex_lock(&mt->lock);
+	list_add_worker(w, &mt->main);
+	pthread_mutex_unlock(&mt->lock);
 
 	while (!fuse_session_exited(mt->se)) {
 		int isforget = 0;
@@ -91,60 +132,27 @@ static void *fuse_do_work(void *data)
 		if (((struct fuse_in_header *) w->buf)->opcode == FUSE_FORGET)
 			isforget = 1;
 
-		if (!isforget)
-			mt->numavail--;
-		if (mt->numavail == 0)
-			fuse_start_thread(mt);
 		pthread_mutex_unlock(&mt->lock);
 
 		fuse_session_process(mt->se, w->buf, res, ch);
-
-		pthread_mutex_lock(&mt->lock);
-		if (!isforget)
-			mt->numavail++;
-		if (mt->numavail > 10) {
-			if (mt->exit) {
-				pthread_mutex_unlock(&mt->lock);
-				return NULL;
-			}
-			list_del_worker(w);
-			mt->numavail--;
-			mt->numworker--;
-			pthread_mutex_unlock(&mt->lock);
-
-			pthread_detach(w->thread_id);
-			free(w->buf);
-			free(w);
-			return NULL;
-		}
-		pthread_mutex_unlock(&mt->lock);
 	}
 
+	free(w->buf);
+	free(w);
 	sem_post(&mt->finish);
 	pause();
 
 	return NULL;
 }
 
-static int fuse_start_thread(struct fuse_mt *mt)
+static int fuse_start_thread(struct thr_init *ti, struct fuse_mt *mt)
 {
 	sigset_t oldset;
 	sigset_t newset;
+	pthread_t pthr;
 	int res;
-	struct fuse_worker *w = malloc(sizeof(struct fuse_worker));
-	if (!w) {
-		fprintf(stderr, "fuse: failed to allocate worker structure\n");
-		return -1;
-	}
-	memset(w, 0, sizeof(struct fuse_worker));
-	w->bufsize = fuse_chan_bufsize(mt->prevch);
-	w->buf = malloc(w->bufsize);
-	w->mt = mt;
-	if (!w->buf) {
-		fprintf(stderr, "fuse: failed to allocate read buffer\n");
-		free(w);
-		return -1;
-	}
+
+	ti->mt = mt;
 
 	/* Disallow signal reception in worker threads */
 	sigemptyset(&newset);
@@ -153,19 +161,14 @@ static int fuse_start_thread(struct fuse
 	sigaddset(&newset, SIGHUP);
 	sigaddset(&newset, SIGQUIT);
 	pthread_sigmask(SIG_BLOCK, &newset, &oldset);
-	res = pthread_create(&w->thread_id, NULL, fuse_do_work, w);
+	res = pthread_create(&pthr, NULL, fuse_do_work, ti);
 	pthread_sigmask(SIG_SETMASK, &oldset, NULL);
 	if (res != 0) {
 		fprintf(stderr, "fuse: error creating thread: %s\n",
 			strerror(res));
-		free(w->buf);
-		free(w);
+		free(ti);
 		return -1;
 	}
-	list_add_worker(w, &mt->main);
-	mt->numavail ++;
-	mt->numworker ++;
-
 	return 0;
 }
 
@@ -181,24 +184,60 @@ static void fuse_join_worker(struct fuse
 
 int fuse_session_loop_mt(struct fuse_session *se)
 {
-	int err;
+	int err, i, j, nnodes;
+	struct thr_init *ti;
 	struct fuse_mt mt;
 	struct fuse_worker *w;
+	struct bitmask *bm;
+	struct cpuset *cs;
 
 	memset(&mt, 0, sizeof(struct fuse_mt));
 	mt.se = se;
 	mt.prevch = fuse_session_next_chan(se, NULL);
 	mt.error = 0;
-	mt.numworker = 0;
-	mt.numavail = 0;
 	mt.main.thread_id = pthread_self();
 	mt.main.prev = mt.main.next = &mt.main;
 	sem_init(&mt.finish, 0, 0);
 	fuse_mutex_init(&mt.lock);
 
+#define PATH_CS_ROOT "/"
+
+	nnodes = cpuset_mems_nbits();
+	cs = cpuset_alloc();
+	bm = bitmask_alloc(nnodes);
+	if (cpuset_query(cs, PATH_CS_ROOT) == -1) {
+		err = -1;
+		goto pass;
+	}
+	if (cpuset_getmems(cs, bm) == -1) {
+		err = -1;
+		goto pass;
+	}
 	pthread_mutex_lock(&mt.lock);
-	err = fuse_start_thread(&mt);
+	for (i = err = 0; !err && i < nnodes; i++) {
+		if (bitmask_isbitset(bm, i)) {
+			bitmask_clearbit(bm, i);
+#define THR_PER_NODE 1
+			for (j = 0; j < THR_PER_NODE; j++) {
+				ti = malloc(sizeof(*ti));
+				if (!ti) {
+					fprintf(stderr, "fuse: failed to allocate worker structure\n");
+					err = -1;
+				} else {
+					memset(ti, 0, sizeof(*ti));
+					ti->bindnode = i;
+					err = fuse_start_thread(ti, &mt);
+					if (err)
+						free(ti);
+				}
+			}
+		}
+	}
 	pthread_mutex_unlock(&mt.lock);
+ pass:
+	bitmask_free(bm);
+	cpuset_free(cs);
+
 	if (!err) {
 		/* sem_wait() is interruptible */
 		while (!fuse_session_exited(se))
